#!/usr/bin/env python3
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "vsjetpack",
#   "numpy",
# ]
# ///

# Requires manually installing:
# Av1an:             Native Windows Version (in VapourSynth folder)
# SVT-AV1:           Native Windows Version
# FFmpeg:            Windows version
# fssimu2:           Native Windows Version (in tools folder) for metrics
# vs-zip:            Required for XPSNR (Default metric)

# Auto-Boost-Essential (Native Windows Edition)
# Modified for Native Av1an + Standard SVT-AV1 flow + fssimu2 + Zones Support

from vstools import vs, core, depth, DitherType, clip_async_render

try:
    from vstools.functions.progress import get_render_progress, FPSColumn
except:
    from vstools.functions.render.progress import get_render_progress, FPSColumn
from rich.progress import (
    Progress,
    TextColumn,
    BarColumn,
    TimeElapsedColumn,
    TimeRemainingColumn,
    SpinnerColumn,
)
from rich.console import Console
from statistics import quantiles
from math import ceil, log10
from pathlib import Path
from collections import Counter
import subprocess
import argparse
import platform
import shutil
import struct
import glob
import sys
import gc
import os
import re
import wakepy
import json
import csv
import numpy as np
import concurrent.futures

ver_str = "v2.9.20 (Clean UI)"

# --- TOOL PATHS CONFIGURATION ---
# Resolved to absolute paths immediately to prevent issues when subprocess changes cwd
if platform.system() == "Windows":
    av1an_exe = Path(r"tools\av1an\av1an.exe").resolve()
    fssimu2_exe = Path(r"tools\fssimu2\fssimu2.exe").resolve()
    cropdetect_script = Path(r"tools\cropdetect.py").resolve()
    use_shell = True
else:
    av1an_exe = shutil.which("av1an")
    if not av1an_exe:
        print("Error: av1an not found in PATH")
        sys.exit(1)

    fssimu2_exe = Path("fssimu2_not_found")
    if shutil.which("fssimu2"):
        fssimu2_exe = Path(shutil.which("fssimu2"))

    # Cropdetect is in tools/ relative to script
    cropdetect_script = Path(__file__).parent / "tools" / "cropdetect.py"
    use_shell = False

# --------------------------------

parser = argparse.ArgumentParser()
parser.add_argument(
    "-s",
    "--stage",
    help="Select stage: 1 = fast encode, 2 = calculate metrics, 3 = generate zones, 4 = final encode | Default: all",
    default=0,
)
parser.add_argument(
    "-i", "--input", required=True, help="Video input filepath (original source file)"
)
parser.add_argument(
    "-o",
    "--output",
    help="Output video filepath | Default: input-av1.mkv",
    default=None,
)
parser.add_argument(
    "--scenes",
    help="Path to external scenes JSON generated by Progressive-Scene-Detection",
)
parser.add_argument(
    "-t",
    "--temp",
    help="The temporary directory for the script to store files in | Default: video input filename",
)
parser.add_argument(
    "--fast-speed",
    help="Fast encode speed (Allowed: 0-10 or presets) | Default: 10",
    default="10",
)
parser.add_argument(
    "--final-speed",
    help="Final encode speed (Allowed: 0-10 or presets) | Default: 4",
    default="4",
)
parser.add_argument(
    "--quality",
    help="Base encoder --quality (Allowed: low, medium, high, breeze or int) | Default: medium",
    default="medium",
)
parser.add_argument(
    "-a",
    "--aggressive",
    action="store_true",
    help="More aggressive boosting | Default: not active",
)
parser.add_argument(
    "-u",
    "--unshackle",
    action="store_true",
    help="Less restrictive boosting | Default: not active",
)
parser.add_argument("--fast-params", help="Custom fast encoding parameters (SVT flags)")
parser.add_argument(
    "--final-params",
    help="Custom final encoding parameters (SVT flags passed to Av1an)",
)
parser.add_argument(
    "--ssimu2",
    help="SSIMU2 mode: auto, gpu, fssimu2, vs-hip | If omitted, defaults to XPSNR",
    default=None,
)
parser.add_argument(
    "--ssimu2-cpu-workers",
    help="Number of workers for SSIMU2 CPU (fssimu2 or vs-zip) | Default: 4",
    default="4",
)
parser.add_argument(
    "--workers", help="Number of Av1an workers | Default: 1", default="1"
)
parser.add_argument(
    "--photon-noise", help="Photon noise strength | Default: 2", default="2"
)
parser.add_argument(
    "--verbose", action="store_true", help="Enable more verbosity | Default: not active"
)
parser.add_argument(
    "-r",
    "--resume",
    action="store_true",
    help="Resume the process from the last (un)completed stage | Default: not active",
)
parser.add_argument(
    "-nb",
    "--no-boosting",
    action="store_true",
    help="Runs the script without boosting (final encode only) | Default: not active",
)
parser.add_argument(
    "--autocrop",
    action="store_true",
    help="Enable automatic crop detection | Default: not active",
)
parser.add_argument(
    "--convert-to-YUV420P10",
    action="store_true",
    help="Convert to YUV420P10 during processing for sources such as 422 or 444 etc | Default: not active",
)
parser.add_argument(
    "-v", "--version", action="version", version=f"Auto-Boost-Essential {ver_str}"
)
parser.add_argument(
    "--debug",
    action="store_true",
    help="Checks the installation and provides relevant information for troubleshooting | Default: not active",
)
parser.add_argument(
    "--zones", help="Path to specific zones file override", default=None
)

args = parser.parse_args()


# --- PRIVACY HELPER ---
def obscure_user_path(text: str) -> str:
    """
    Replaces any username in C:\\Users\\<username> with 'av1enjoyer'
    to obscure the real username in console output.
    """
    if platform.system() == "Windows":
        return re.sub(
            r"(Users[\\/])([^\\/]+)", r"\1av1enjoyer", text, flags=re.IGNORECASE
        )
    return text


# ----------------------


# --- SETTINGS PARSER ---
def get_script_setting(key_name: str, default_value: str) -> str:
    """
    Parses settings.txt from the script's directory (or current dir) for specific keys.
    Does not rely on line numbers, searches for 'key=value'.
    """
    # Look for settings.txt in same folder as script
    script_dir = Path(__file__).parent.resolve()
    settings_path = script_dir / "settings.txt"

    if not settings_path.exists():
        # Fallback to current working directory
        settings_path = Path.cwd() / "settings.txt"

    if not settings_path.exists():
        return default_value

    try:
        with open(settings_path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                # Skip comments
                if line.startswith("#") or line.startswith(";"):
                    continue
                if "=" in line:
                    k, v = line.split("=", 1)
                    if k.strip().lower() == key_name.lower():
                        return v.strip()
    except Exception:
        pass

    return default_value


# Load Settings
s_downscale = get_script_setting("downscale", "False")
s_target_res = get_script_setting("target_resolution", "1920x1080")
s_kernel = get_script_setting("kernel_type", "Hermite")

# Normalize boolean string
do_downscale_bool = s_downscale.lower() == "true"
# -----------------------

stage = int(args.stage)
src_file = Path(args.input).resolve()
if platform.system() == "Windows":
    src_file = type(src_file)(r"\\?" + rf"\{src_file}")
file_ext = src_file.suffix
output_dir = src_file.parent
if args.temp is not None:
    tmp_dir = Path(args.temp).resolve()
    if platform.system() == "Windows":
        tmp_dir = type(tmp_dir)(r"\\?" + rf"\{tmp_dir}")
else:
    tmp_dir = output_dir / f".{src_file.stem}.temp"

# Files
vpy_file = tmp_dir / f"{src_file.stem}.vpy"
cache_file = tmp_dir / f"{src_file.stem}.ffindex"
# Fast pass is now MKV
# Fast pass is now MKV
fast_output_file = tmp_dir / f"{src_file.stem}_fastpass.mkv"
# Final output
if args.output:
    final_output_file = Path(args.output).resolve()
else:
    final_output_file = output_dir / f"{src_file.stem}-av1.mkv"
tmp_final_output_file = tmp_dir / f"{src_file.stem}-av1.mkv"

ssimu2_log_file = tmp_dir / f"{src_file.stem}_ssimu2.log"
xpsnr_log_file = tmp_dir / f"{src_file.stem}_xpsnr.log"
scenes_file = tmp_dir / f"{src_file.stem}_scenes.json"
stage_file = tmp_dir / f"{src_file.stem}_stage.txt"
stage_resume = 0

# Handle external scenes path
external_scenes_file = None
if args.scenes:
    external_scenes_file = Path(args.scenes).resolve()
    if not external_scenes_file.exists():
        print(
            f"Warning: External scenes file {external_scenes_file} not found. Will fallback to internal detection."
        )
        external_scenes_file = None

# Speed Mapping
speed_map = {
    "slower": "2",
    "slow": "4",
    "medium": "6",
    "fast": "8",
    "faster": "10",
    "0": "0",
}

fast_speed = str(args.fast_speed)
if fast_speed.lower() in speed_map:
    fast_speed = speed_map[fast_speed.lower()]

final_speed = str(args.final_speed)
if final_speed.lower() in speed_map:
    final_speed = speed_map[final_speed.lower()]

quality = args.quality
aggressive = args.aggressive
unshackle = args.unshackle
fast_params = args.fast_params if args.fast_params is not None else ""
final_params = args.final_params if args.final_params is not None else ""

# Handle ssimu2 default
if args.ssimu2 is None:
    ssimu2 = ""
else:
    ssimu2 = args.ssimu2.lower()

ssimu2_cpu_workers = int(args.ssimu2_cpu_workers)
verbose = args.verbose
resume = args.resume
no_boosting = args.no_boosting
convert_yuv420p10 = args.convert_to_YUV420P10
av1an_workers = args.workers
photon_noise_val = int(args.photon_noise)

if args.debug:
    print("=" * 54)
    print("SYSTEM INFORMATION")
    print("=" * 54)
    print(f"System: {platform.platform()}")
    print(f"Python Version: {sys.version}")
    print("=" * 54)
    print("Check for Tools")
    print("=" * 54)
    print(f"Av1an Path:   {av1an_exe}")
    # print(f"Av1an Exists: {av1an_exe.exists()}") # av1an_exe might be string on Linux if not Path object
    print(f"fssimu2 Path:   {fssimu2_exe}")
    print(
        f"fssimu2 Exists: {fssimu2_exe.exists() if isinstance(fssimu2_exe, Path) else 'Unknown'}"
    )
    print(f"Cropdetect Path: {cropdetect_script}")
    print(f"Cropdetect Exists: {cropdetect_script.exists()}")
    raise SystemExit(1)

if not os.path.exists(src_file):
    print("The source input doesn't exist. Double-check the provided path.")
    raise SystemExit(1)

if "--preset" in fast_params.split():
    print("Please use --fast-speed argument instead of putting --preset in fast-params")
    raise SystemExit(1)

if "--crf" in fast_params:
    index = fast_params.index("--crf")
    try:
        quality = float(fast_params[index + 6 : index + 11])
    except:
        try:
            quality = float(fast_params[index + 6 : index + 10])
        except:
            try:
                quality = float(fast_params[index + 6 : index + 8])
            except:
                print("CRF must have 0, 1 or 2 decimals.")
                raise SystemExit(1)
else:
    if quality not in ["low", "medium", "high", "breeze"]:
        try:
            float(quality)
        except ValueError:
            print(
                "The quality preset must be either low, medium, high, breeze or a number."
            )
            raise SystemExit(1)

if stage != 0 and resume:
    print(
        "Resume will auto-resume from the last (un)completed stage. You cannot provide both stage and resume."
    )
    raise SystemExit(1)

if os.path.exists(tmp_dir):
    if resume and os.path.exists(stage_file):
        with open(stage_file, "r") as file:
            lines = file.readlines()
            stage_resume = int(lines[0].strip())
            if stage_resume == 5:
                print("Final encode already finished. Nothing to resume.")
                raise SystemExit(0)
            else:
                print(f"Resuming from stage {stage_resume}.")

    if not resume and stage in [0, 1]:
        shutil.rmtree(tmp_dir)

if not os.path.exists(tmp_dir):
    os.makedirs(tmp_dir)

core.max_cache_size = 1024
console = Console()


def detect_crop_values(source_path: Path) -> tuple[int, int]:
    """
    Uses external tools/cropdetect.py to detect crop values.
    Saves the CSV to the source directory (next to the input file/bat file).
    """
    console.print("Detecting crop values via cropdetect.py...")
    # Just show filename, not the scary long path
    console.print(f"[cyan]{source_path.name}[/cyan]")

    if not cropdetect_script.exists():
        console.print(
            f"[red]cropdetect.py not found at {cropdetect_script}. Proceeding with 0 crop.[/red]"
        )
        return 0, 0

    csv_output = source_path.parent / f"{source_path.stem}_crop.csv"

    # We use --progress-mode to get machine-readable updates
    cmd = [
        sys.executable,
        str(cropdetect_script),
        str(source_path),
        "--out",
        str(csv_output),
        "--aggressive",
        "--samples",
        "3",
        "--progress-mode",
    ]

    # Run process and stream output to update progress bar
    try:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            "[progress.percentage]{task.percentage:>3.0f}%",
            TimeRemainingColumn(),
            console=console,
        ) as progress:
            task = progress.add_task("[green]Sampling...", total=100)

            # Popen allows real-time output reading
            with subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding="utf-8",
            ) as proc:
                for line in proc.stdout:
                    line = line.strip()
                    if line.startswith("PROGRESS:"):
                        try:
                            # Parse PROGRESS:X
                            percent = int(line.split(":")[1])
                            progress.update(task, completed=percent)
                        except (IndexError, ValueError):
                            pass
                    elif verbose:
                        # Only show other lines if verbose is on
                        # This keeps the main UI clean
                        console.print(f"[dim]{line}[/dim]")

                # Check return code
                if proc.wait() != 0:
                    console.print(
                        "[red]Crop detection process finished with errors.[/red]"
                    )

    except Exception as e:
        console.print(f"[red]Error during crop detection execution: {e}[/red]")
        return 0, 0

    if not csv_output.exists():
        console.print(
            f"[yellow]Crop CSV not found after execution. Defaulting to 0.[/yellow]"
        )
        return 0, 0

    # Read the CSV to get final values
    try:
        with open(csv_output, newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            rows = list(reader)
            if not rows:
                console.print(
                    "[yellow]Cropdetect CSV was empty. Defaulting to 0.[/yellow]"
                )
                return 0, 0

            row = rows[0]
            orig_h = int(row["height"])
            c_h = int(row["crop_h"])
            c_y = int(row["crop_y"])

            crop_top = c_y
            crop_bottom = orig_h - (c_y + c_h)

            # Ensure mod2
            if crop_top % 2 != 0:
                crop_top -= 1
            if crop_bottom % 2 != 0:
                crop_bottom -= 1

            console.print(
                f"[bold green]Crop Found:[/bold green] Top={crop_top}, Bottom={crop_bottom} [dim](Based on {row['crop']})[/dim]"
            )
            return crop_top, crop_bottom

    except Exception as e:
        console.print(f"[red]Failed to parse crop CSV: {e}[/red]")
        return 0, 0


# Generate VPY file
if not os.path.exists(vpy_file):
    crop_top, crop_bottom = 0, 0
    if args.autocrop:
        crop_top, crop_bottom = detect_crop_values(src_file)

    # Template - Updated to match Windows v1.5 with downscaling support
    vpy_template = """
from vstools import vs, core, initialize_clip, finalize_clip
core.max_cache_size = 1024

# Load Source
src = core.ffms2.Source(source=r"{source}", cachefile=r"{cache}")

# Conversion
if {convert}:
    src = src.resize.Bicubic(format=vs.YUV420P10)

# Initialize (Fixes Placebo bitdepth error by ensuring 16-bit)
src = initialize_clip(src)

# 1. CROP
if {ct} > 0 or {cb} > 0:
    src = src.std.Crop(top={ct}, bottom={cb})

# 2. DOWNSCALE
should_downscale = {downscale}
target_res_str = "{target_res}"
user_kernel = "{kernel}"

if should_downscale:
    # Kernel Map
    k_map = {{
        "hermite": "hermite",
        "bilinear": "triangle",
        "bicubic": "catmull_rom",
        "gaussian": "gaussian",
        "catmull_rom": "catmull_rom",
        "mitchell": "mitchell",
        "lanczos": "lanczos",
        "spline36": "spline36"
    }}
    pl_filter = k_map.get(user_kernel.lower(), "spline36")

    # Parse Target Resolution
    target_w = 0
    target_h = 0
    
    if "x" in target_res_str.lower():
        try:
            w_str, h_str = target_res_str.lower().split("x")
            target_w = int(w_str)
            target_h = int(h_str)
        except:
            pass
    else:
        try:
            target_w = int(target_res_str)
        except:
            pass
            
    # Calculate Height
    if target_w > 0:
        if target_h == 0:
            target_h = int(target_w * src.height / src.width)
            if target_h % 2 != 0:
                target_h -= 1
        
        if target_w % 2 != 0:
            target_w -= 1
            
        if target_w < src.width or target_h < src.height:
             src = core.placebo.Resample(src, target_w, target_h, filter=pl_filter)

# Finalize (Sets 10-bit output)
final = finalize_clip(src)
final.set_output(0)
"""

    # Write VPY
    with open(vpy_file, "w") as file:
        file.write(
            vpy_template.format(
                source=src_file,
                cache=cache_file,
                ct=crop_top,
                cb=crop_bottom,
                downscale=str(do_downscale_bool),
                target_res=s_target_res,
                kernel=s_kernel,
                convert=convert_yuv420p10,
            )
        )


def get_file_info(
    vfile: Path, mode: str
) -> tuple[list[int], bool, int, int, int, int, int]:
    if mode == "src":
        kf_file = tmp_dir / "info_src.txt"
    else:
        kf_file = tmp_dir / "info.txt"

    if kf_file.exists() and mode == "src" and (stage != 0 or resume):
        with open(kf_file, "r") as file:
            print("Loading cached scene information...")
            lines = file.readlines()
            return (
                [int(line.strip()) for line in lines[1:-3]],
                lines[0].strip() == "True",
                int(lines[-5].strip()),
                int(lines[-4].strip()),
                int(lines[-3].strip()),
                int(lines[-2].strip()),
                int(lines[-1].strip()),
            )

    # Setup VPY environment to get src info from Windows VPY
    vpy_vars = {}
    exec(open(vpy_file).read(), globals(), vpy_vars)

    if mode == "src":
        src = vpy_vars["src"]
    else:
        # For encoded file (MKV/IVF), we use FFMS2
        src = core.ffms2.Source(source=vfile, cache=False)

    nframe = len(src)
    if mode == "len":
        return 0, 0, nframe, 0, 0, 0, 0

    fwidth, fheight = src.width, src.height
    hr = fwidth * fheight > 1920 * 1080
    with open(kf_file, "w") as file:
        file.write(str(hr) + "\n")

    ffpsnum = src.fps.numerator
    ffpsden = src.fps.denominator

    iframe_list = []

    # If external scenes are provided, use them instead of scanning
    if mode == "src" and external_scenes_file is not None:
        console.print(
            f"[green]Using external scenes: {external_scenes_file.name}[/green]"
        )
        try:
            with open(external_scenes_file, "r") as f:
                scene_data = json.load(f)
            # Progressive-Scene-Detection outputs "scenes" list with "start_frame"
            if "scenes" in scene_data:
                for s in scene_data["scenes"]:
                    iframe_list.append(s["start_frame"])
            else:
                console.print(
                    "[red]Invalid external scenes JSON format. Falling back to detection.[/red]"
                )
                # Fallback logic handled below by checking if iframe_list is empty
        except Exception as e:
            console.print(
                f"[red]Error reading external scenes: {e}. Falling back to detection.[/red]"
            )

    if mode == "src" and not iframe_list:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            "[progress.percentage]{task.percentage:>3.0f}%",
            FPSColumn(),
            TimeElapsedColumn(),
            TimeRemainingColumn(),
            console=console,
        ) as progress:
            task = progress.add_task("[green]Analyzing Scenes (SCDetect)", total=nframe)

            def progress_func(n: int, num_frames: int) -> None:
                progress.update(task, completed=n)

            # Create a lightweight analysis clip (360p, 8-bit) for fast SCDetect
            analysis_clip = src.resize.Bilinear(640, 360, format=vs.YUV420P8)
            analysis_clip = analysis_clip.misc.SCDetect(threshold=0.1)

            def get_props(n: int, f: vs.VideoFrame) -> None:
                if n == 0 or f.props.get("_SceneChangePrev") == 1:
                    iframe_list.append(n)

            clip_async_render(
                analysis_clip, outfile=None, progress=progress_func, callback=get_props
            )
            progress.update(
                task, description="[cyan]Scenes Analyzed         ", completed=nframe
            )

    with open(kf_file, "a") as file:
        file.write("\n".join(map(str, iframe_list)))

    with open(kf_file, "a") as file:
        file.write(f"\n{nframe}\n{fwidth}\n{fheight}\n{ffpsnum}\n{ffpsden}")

    return iframe_list, hr, nframe, fwidth, fheight, ffpsnum, ffpsden


def fast_pass() -> None:
    """
    Fast pass using native Av1an to generate an MKV file.
    """
    encoder_params = f"--preset {fast_speed} "

    # Check if CRF is manually specified in fast_params
    needs_crf = True
    if fast_params and "--crf" in fast_params:
        needs_crf = False

    if needs_crf:
        # Load VPY to check for HR content (High Resolution)
        try:
            vpy_vars = {}
            exec(open(vpy_file).read(), globals(), vpy_vars)
            src = vpy_vars["src"]
            hr = src.width * src.height > 1920 * 1080
        except Exception as e:
            if verbose:
                console.print(
                    f"[yellow]Warning: Could not determine resolution from VPY, defaulting hr=False. Error: {e}[/yellow]"
                )
            hr = False

        # Match CRF based on user quality setting
        match quality:
            case "low":
                crf = 40 if hr else 35
            case "medium":
                crf = 35 if hr else 30
            case "high":
                crf = 30 if hr else 25
            case "breeze":
                crf = 18 if hr else 18
            case _:
                crf = float(quality)

        encoder_params += f" --crf {crf} "

    if fast_params:
        encoder_params += f"{fast_params}"

    if verbose:
        console.print(f'Fast params: "{encoder_params}"')

    # Av1an command - Native
    av1an_cmd = [
        str(av1an_exe),
        "-i",
        vpy_file.name,  # Just the filename
        "-e",
        "svt-av1",
        "-c",
        "mkvmerge",
        "-w",
        "1",
        "-x",
        "0",
        "--resume",
        "--verbose",
        "--split-method",
        "none",
        "-v",
        encoder_params,
        "-o",
        fast_output_file.name,  # Just the filename
    ]

    print("-" * 50)
    print(f"Running Fast Pass (Native) in: {obscure_user_path(str(tmp_dir))}")
    print(f"Command:\n{obscure_user_path(' '.join(av1an_cmd))}")
    print("-" * 50)

    try:
        # Run in tmp_dir so it picks up files from current dir
        subprocess.run(av1an_cmd, check=True, cwd=tmp_dir)
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Fast pass failed:[/red]\n{e}")
        raise SystemExit(1)


def final_pass() -> None:
    """
    Final encoding pass using native Av1an.
    """
    if not scenes_file.exists() and not no_boosting:
        console.print("[red]Scenes file not found![/red]")
        raise SystemExit(1)

    av1an_cmd = [
        str(av1an_exe),
        "-i",
        vpy_file.name,  # Just the filename
        "-y",
        "--workers",
        str(av1an_workers),
        "--resume",
        "--no-defaults",
        "--keep",
        "--photon-noise",
        str(photon_noise_val),
        "-e",
        "svt-av1",
        "-o",
        tmp_final_output_file.name,  # Just the filename
    ]

    if not no_boosting:
        # Use generated scenes
        av1an_cmd.extend(["-s", scenes_file.name])
    else:
        v_params = f"--preset {final_speed} --crf {quality} {final_params}"
        av1an_cmd.extend(["-v", v_params])

    # Show command ALWAYS per user request
    print("-" * 50)
    print(f"Running Final Pass (Native) in: {obscure_user_path(str(tmp_dir))}")
    print(f"Command:\n{obscure_user_path(' '.join(av1an_cmd))}")
    print("-" * 50)

    try:
        # Run in tmp_dir so it picks up files from current dir
        subprocess.run(av1an_cmd, check=True, cwd=tmp_dir)
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Final pass failed:[/red]\n{e}")
        raise SystemExit(1)


def calculate_metric() -> None:
    # Import needed for parallelism
    import concurrent.futures

    # Use Windows VPY for source
    vpy_vars = {}
    exec(open(vpy_file).read(), globals(), vpy_vars)
    source_clip = vpy_vars["src"]

    # Read Fast Pass MKV
    try:
        if not fast_output_file.exists():
            console.print(
                "[red]Fast pass output file not found. Did the fast pass fail?[/red]"
            )
            raise SystemExit(1)
        encoded_clip = core.ffms2.Source(source=fast_output_file, cache=False)
    except Exception as e:
        console.print(f"[red]Error indexing fast pass file: {e}[/red]")
        raise SystemExit(1)

    if len(source_clip) != len(encoded_clip):
        console.print(
            f"[red]Frame count mismatch: Src {len(source_clip)} vs Enc {len(encoded_clip)}[/red]"
        )
        raise SystemExit(1)

    skip = 3
    cut_source_clip = source_clip[::skip]
    cut_encoded_clip = encoded_clip[::skip]

    global ssimu2

    # ----------------------------------------------------
    # 1. ATTEMPT XPSNR (Default if ssimu2 is empty)
    # ----------------------------------------------------
    if ssimu2 == "":
        console.print("[yellow]Calculating XPSNR (Default)...[/yellow]")
        try:
            # Check for vszip
            if not hasattr(core, "vszip"):
                console.print("[red]vs-zip plugin not found! Required for XPSNR.[/red]")
                raise SystemExit(1)

            result = core.vszip.XPSNR(
                cut_source_clip, cut_encoded_clip, temporal=False, verbose=False
            )

            # XPSNR requires storing Y, U, V separately
            score_list = [[None] * cut_source_clip.num_frames for _ in range(3)]

            def get_xpsnrprops(n: int, f: vs.VideoFrame) -> None:
                for i, plane in enumerate(["Y", "U", "V"]):
                    val = f.props.get(f"XPSNR_{plane}")
                    # inf = perfect match
                    if str(val) == "inf":
                        score_list[i][n] = "100.0"
                    else:
                        score_list[i][n] = float(val)

            with Progress(
                SpinnerColumn(), BarColumn(), FPSColumn(), console=console
            ) as p:
                task = p.add_task(
                    "Calculating XPSNR", total=cut_source_clip.num_frames * skip
                )

                def update_p(n, t):
                    p.update(task, advance=skip)

                clip_async_render(result, progress=update_p, callback=get_xpsnrprops)

            # Write Log
            with open(xpsnr_log_file, "w") as file:
                skip_offset = 0
                for index in range(len(score_list[0])):
                    val_y = score_list[0][index]
                    val_u = score_list[1][index]
                    val_v = score_list[2][index]

                    if val_y is None:
                        val_y = 0.0
                    if val_u is None:
                        val_u = 0.0
                    if val_v is None:
                        val_v = 0.0

                    for i in range(skip):
                        file.write(
                            f"{index + skip_offset + i}: {val_y} {val_u} {val_v}\n"
                        )
                    skip_offset += skip - 1
            return

        except Exception as e:
            console.print(f"[red]XPSNR calculation failed: {e}[/red]")
            raise SystemExit(1)

    # ----------------------------------------------------
    # 2. SSIMULACRA2 BRANCH
    # ----------------------------------------------------

    score_list = [None] * cut_source_clip.num_frames

    tried_vship = False
    metric_calculated = False

    # ATTEMPT GPU (VS-HIP / VSHIP)
    if ssimu2 in ["auto", "gpu", "vs-hip"]:
        tried_vship = True
        console.print("[yellow]Attempting SSIMULACRA2 via VS-HIP (GPU)...[/yellow]")

        try:
            if not hasattr(core, "vship"):
                raise ImportError("Vship plugin (vs-hip) not found in VapourSynth.")

            # Run Vship
            result = core.vship.SSIMULACRA2(
                cut_source_clip, cut_encoded_clip, numStream=3
            )

            def get_ssimu2props_vship(n, f):
                val = f.props.get("_SSIMULACRA2")
                if val is None:
                    val = f.props.get("SSIMULACRA2")
                if val is None:
                    score_list[n] = 0.0
                else:
                    score_list[n] = float(val)

            with Progress(
                SpinnerColumn(), BarColumn(), FPSColumn(), console=console
            ) as p:
                task = p.add_task(
                    "Calculating SSIMULACRA2 (VS-HIP)",
                    total=cut_source_clip.num_frames * skip,
                )

                def update_p(n, t):
                    p.update(task, advance=skip)

                clip_async_render(
                    result, progress=update_p, callback=get_ssimu2props_vship
                )

            metric_calculated = True

        except Exception as e:
            if ssimu2 == "auto":
                console.print(
                    f"[yellow]VS-HIP failed or not found ({e}). Falling back to next method.[/yellow]"
                )
            else:
                console.print(f"[red]VS-HIP failed: {e}.[/red]")
                raise SystemExit(1)

    if metric_calculated:
        # Write log and exit function
        with open(ssimu2_log_file, "w") as file:
            skip_offset = 0
            for index, score in enumerate(score_list):
                final_score = score if score is not None else 0.0
                for i in range(skip):
                    file.write(f"{index + skip_offset + i}: {final_score}\n")
                skip_offset += skip - 1
        return

    # ATTEMPT BINARY (fssimu2)
    fallback_needed = False

    if ssimu2 in ["auto", "fssimu2"]:
        if not fssimu2_exe.exists():
            if ssimu2 == "auto":
                console.print(
                    f"[yellow]fssimu2 binary not found at {fssimu2_exe}! Switching to fallback.[/yellow]"
                )
                fallback_needed = True
            else:
                console.print(
                    f"[red]fssimu2 binary not found at {fssimu2_exe}! Cannot calculate metrics.[/red]"
                )
                raise SystemExit(1)

        if not fallback_needed:
            console.print(
                f"[yellow]Calculating SSIMULACRA2 via fssimu2 (Binary | {ssimu2_cpu_workers} Workers)...[/yellow]"
            )

            # Convert to RGB24 for PAM export
            ref_rgb = cut_source_clip.resize.Bicubic(format=vs.RGB24, matrix_in_s="709")
            dist_rgb = cut_encoded_clip.resize.Bicubic(
                format=vs.RGB24, matrix_in_s="709"
            )

            # Helper function to write PAM
            def write_pam(frame, filepath):
                width, height = frame.width, frame.height
                r = np.asarray(frame[0])
                g = np.asarray(frame[1])
                b = np.asarray(frame[2])
                packed = np.dstack((r, g, b)).tobytes()
                header = (
                    f"P7\n"
                    f"WIDTH {width}\n"
                    f"HEIGHT {height}\n"
                    f"DEPTH 3\n"
                    f"MAXVAL 255\n"
                    f"TUPLTYPE RGB\n"
                    f"ENDHDR\n"
                ).encode()
                with open(filepath, "wb") as f:
                    f.write(header)
                    f.write(packed)

            # WORKER FUNCTION FOR PARALLEL EXECUTION
            def process_frame(n):
                if fallback_needed:
                    return n, 0.0  # Abort

                f_ref = ref_rgb.get_frame(n)
                f_dist = dist_rgb.get_frame(n)

                current_ref_path = tmp_dir / f"ref_{n}.pam"
                current_dist_path = tmp_dir / f"dist_{n}.pam"

                write_pam(f_ref, current_ref_path)
                write_pam(f_dist, current_dist_path)

                ref_str = str(current_ref_path).replace("\\\\?\\", "")
                dist_str = str(current_dist_path).replace("\\\\?\\", "")

                cmd = [str(fssimu2_exe), ref_str, dist_str]
                score = 0.0

                try:
                    res = subprocess.run(
                        cmd, capture_output=True, text=True, check=True, shell=use_shell
                    )
                    output = res.stdout.strip() or res.stderr.strip()
                    score = float(output)

                except subprocess.CalledProcessError as e:
                    console.print(f"[red]fssimu2 crashed at frame {n * skip}.[/red]")
                    raise RuntimeError("fssimu2_crash")
                except ValueError:
                    console.print(
                        f"[red]fssimu2 returned invalid output at frame {n * skip}[/red]"
                    )
                    raise RuntimeError("fssimu2_invalid")

                try:
                    current_ref_path.unlink(missing_ok=True)
                    current_dist_path.unlink(missing_ok=True)
                except:
                    pass

                return n, score

            try:
                workers_count = ssimu2_cpu_workers
                with Progress(
                    SpinnerColumn(),
                    BarColumn(),
                    FPSColumn(),
                    TimeRemainingColumn(),
                    console=console,
                ) as p:
                    task = p.add_task(
                        f"Calculating SSIMULACRA2 ({workers_count} Workers)",
                        total=ref_rgb.num_frames * skip,
                    )

                    with concurrent.futures.ThreadPoolExecutor(
                        max_workers=workers_count
                    ) as executor:
                        future_to_frame = {
                            executor.submit(process_frame, n): n
                            for n in range(ref_rgb.num_frames)
                        }

                        for future in concurrent.futures.as_completed(future_to_frame):
                            try:
                                n, score = future.result()
                                score_list[n] = score
                                p.update(task, advance=skip)
                            except RuntimeError:
                                if ssimu2 == "auto":
                                    console.print(
                                        "[red]Crash detected in worker! Switching to fallback...[/red]"
                                    )
                                    fallback_needed = True
                                    executor.shutdown(wait=False, cancel_futures=True)
                                    break
                                else:
                                    console.print(
                                        "[red]Crash detected in worker! Aborting.[/red]"
                                    )
                                    raise SystemExit(1)
            except Exception as e:
                if ssimu2 == "auto":
                    console.print(
                        f"[yellow]Exception during pool execution: {e}. Fallback triggered.[/yellow]"
                    )
                    fallback_needed = True
                else:
                    console.print(f"[red]Exception during pool execution: {e}.[/red]")
                    raise SystemExit(1)

            if not fallback_needed:
                metric_calculated = True

    # FALLBACK CPU (VS-ZIP)
    console.print(
        f"[yellow]Calculating SSIMULACRA2 (VS-ZIP Fallback | {ssimu2_cpu_workers} workers)...[/yellow]"
    )

    core.num_threads = ssimu2_cpu_workers

    try:
        if not hasattr(core, "vszip") or not hasattr(core.vszip, "SSIMULACRA2"):
            console.print(
                "[red]Error: vs-zip plugin not found or does not support SSIMULACRA2. Cannot fallback.[/red]"
            )
            raise SystemExit(1)

        fallback_ref = cut_source_clip.resize.Bicubic(
            format=vs.RGB24, matrix_in_s="709"
        )
        fallback_dist = cut_encoded_clip.resize.Bicubic(
            format=vs.RGB24, matrix_in_s="709"
        )

        result = core.vszip.SSIMULACRA2(fallback_ref, fallback_dist)

        score_list = [None] * cut_source_clip.num_frames

        def get_ssimprops(n, f):
            val = f.props.get("_SSIMULACRA2")
            if val is None:
                val = f.props.get("SSIMULACRA2")
            if val is None:
                val = f.props.get("float_ssimulacra2")

            if val is None:
                if n == 0:
                    console.print(
                        "[red]Warning: _SSIMULACRA2 property missing in fallback frame 0[/red]"
                    )
                score_list[n] = 0.0
            else:
                score_list[n] = float(val)

        with Progress(SpinnerColumn(), BarColumn(), FPSColumn(), console=console) as p:
            task = p.add_task(
                f"Calculating SSIMULACRA2 (VS-ZIP)",
                total=cut_source_clip.num_frames * skip,
            )

            def update_p(n, t):
                p.update(task, advance=skip)

            clip_async_render(result, progress=update_p, callback=get_ssimprops)

    except Exception as e:
        console.print(f"[red]Fallback failed: {e}[/red]")
        raise SystemExit(1)

    with open(ssimu2_log_file, "w") as file:
        skip_offset = 0
        for index, score in enumerate(score_list):
            final_score = score if score is not None else 0.0
            for i in range(skip):
                file.write(f"{index + skip_offset + i}: {final_score}\n")
            skip_offset += skip - 1


def metrics_aggregation(score_list: list[float]) -> tuple[float, float, float]:
    filtered_score_list = [score if score >= 0 else 0.0 for score in score_list]
    sorted_score_list = sorted(filtered_score_list)

    if not sorted_score_list:
        return 0.0, 0.0, 0.0

    average = sum(filtered_score_list) / len(filtered_score_list)

    # Handle single-frame or extremely short scenes where quantiles fails (needs >=2 points)
    if len(sorted_score_list) < 2:
        return (average, sorted_score_list[0], sorted_score_list[0])

    percentile_15 = quantiles(sorted_score_list, n=100)[14]
    min_score = sorted_score_list[0]
    return (average, percentile_15, min_score)


# --- ZONES HELPERS ---


def find_zones_file(video_path: Path) -> Path | None:
    """
    Looks for a zones file matching sXXeXX pattern.
    Example: Awesome.Show.S01E02.mkv matches s01e02-zones.txt
    """
    stem = video_path.stem
    # Match S01E02 or s01e02 case insensitive
    match = re.search(r"([sS]\d{2}[eE]\d{2})", stem)
    if not match:
        return None

    ep_str = match.group(1).lower()
    zones_filename = f"{ep_str}-zones.txt"
    zones_path = video_path.parent / zones_filename

    if zones_path.exists():
        return zones_path
    return None


def parse_param_string_to_dict(param_list: list[str]) -> dict:
    """
    Converts a list of params ['--crf', '20', '--enable-cdef', '1']
    into a dict {'--crf': '20', '--enable-cdef': '1'}.
    Handles boolean flags (no value) if necessary, though SVT usually has values.
    """
    d = {}
    i = 0
    while i < len(param_list):
        key = param_list[i]
        if key.startswith("--"):
            # Check if next item exists and is not a flag
            if i + 1 < len(param_list) and not param_list[i + 1].startswith("--"):
                d[key] = param_list[i + 1]
                i += 2
            else:
                # Boolean flag or flag at end
                d[key] = None
                i += 1
        else:
            # stray value? ignore
            i += 1
    return d


def dict_to_param_list(d: dict) -> list[str]:
    l = []
    for k, v in d.items():
        l.append(k)
        if v is not None:
            l.append(v)
    return l


def merge_params(
    base_params: list[str], zone_params_str: str
) -> tuple[list[str], int | None]:
    """
    Merges base params with zone params.
    Returns (new_param_list, photon_noise_override).
    """
    base_dict = parse_param_string_to_dict(base_params)

    # Split zone params string into list
    zone_list = zone_params_str.strip().split()
    zone_dict = parse_param_string_to_dict(zone_list)

    photon_noise_val = None

    # Update base with zone
    for k, v in zone_dict.items():
        if k == "--photon-noise":
            try:
                photon_noise_val = int(v)
            except:
                pass
            # Do not add photon noise to video_params dict
        else:
            base_dict[k] = v

    # Reconstruct list
    return dict_to_param_list(base_dict), photon_noise_val


# ---------------------


def calculate_zones_json(ranges: list[float], hr: bool, nframe: int) -> None:
    metric_scores = []

    # If using XPSNR (Default behavior if ssimu2 string is empty)
    if ssimu2 == "":
        if not xpsnr_log_file.exists():
            console.print("[red]XPSNR log file missing! Did stage 2 finish?[/red]")
            raise SystemExit(1)

        with open(xpsnr_log_file, "r") as file:
            for line in file:
                # Format: "frame: y u v"
                match = re.search(
                    r"([0-9]+): ([0-9]+\.[0-9]+) ([0-9]+\.[0-9]+) ([0-9]+\.[0-9]+)",
                    line,
                )
                if match:
                    score_y, score_u, score_v = (
                        float(match.group(2)),
                        float(match.group(3)),
                        float(match.group(4)),
                    )
                    maxval = 255
                    # Convert PSNR to MSE
                    # avoid div by zero if perfect match
                    try:
                        mse_y = (maxval**2) / (10 ** (score_y / 10))
                        mse_u = (maxval**2) / (10 ** (score_u / 10))
                        mse_v = (maxval**2) / (10 ** (score_v / 10))
                    except OverflowError:
                        mse_y, mse_u, mse_v = 0.0001, 0.0001, 0.0001  # approx 0

                    # 4:1:1 weighted average (Y is dominant)
                    w_mse = ((4.0 * mse_y) + mse_u + mse_v) / 6.0

                    if w_mse <= 0:
                        w_mse = 0.000001

                    # Convert back to Logarithmic Score (Similar to PSNR but weighted)
                    score_weighted = 10.0 * log10((maxval**2) / w_mse)
                    metric_scores.append(score_weighted)
    else:
        # SSIMU2 read
        with open(ssimu2_log_file, "r") as file:
            for line in file:
                match = re.search(r"([0-9]+): (-?[0-9eE\.\-\+]+)", line)
                if match:
                    metric_scores.append(float(match.group(2)))

    metric_total_scores = []
    metric_percentile_15_total = []

    for index in range(len(ranges)):
        metric_chunk_scores = []
        if index == len(ranges) - 1:
            metric_frames = nframe - ranges[index]
        else:
            metric_frames = ranges[index + 1] - ranges[index]

        for scene_index in range(metric_frames):
            try:
                metric_score = metric_scores[ranges[index] + scene_index]
                metric_chunk_scores.append(metric_score)
                metric_total_scores.append(metric_score)
            except IndexError:
                pass

        if metric_chunk_scores:
            (metric_average, metric_percentile_15, _) = metrics_aggregation(
                metric_chunk_scores
            )
            metric_percentile_15_total.append(metric_percentile_15)
        else:
            metric_percentile_15_total.append(0)

    (metric_average, _, _) = metrics_aggregation(metric_total_scores)

    match quality:
        case "low":
            crf = 40 if hr else 35
        case "medium":
            crf = 35 if hr else 30
        case "high":
            crf = 30 if hr else 25
        case "breeze":
            crf = 18 if hr else 18
        case _:
            crf = float(quality)

    # 1. Generate Base Auto-Boost Scenes
    base_scenes = []

    for index in range(len(ranges)):
        multiplier = 40 if aggressive else 20
        if metric_average == 0:
            metric_average = 1

        adjustment = (
            ceil(
                (1.0 - (metric_percentile_15_total[index] / metric_average))
                * multiplier
                * 4
            )
            / 4
        )
        new_crf = crf - adjustment

        limit = 10 if unshackle else 5
        if adjustment < -limit:
            new_crf = crf + limit
        elif adjustment > limit:
            new_crf = crf - limit

        start_frame = ranges[index]
        if index == len(ranges) - 1:
            end_frame = nframe
        else:
            end_frame = ranges[index + 1]

        if verbose:
            console.print(
                f"Chunk: [{start_frame}:{end_frame}] / 15th: {metric_percentile_15_total[index]:.2f} / CRF: {new_crf}"
            )

        extra_params = final_params.split() if final_params else []
        scene_params = [
            "--preset",
            final_speed,
            "--crf",
            f"{new_crf:.2f}",
        ] + extra_params

        base_scenes.append(
            {
                "start_frame": start_frame,
                "end_frame": end_frame,
                "photon_noise": photon_noise_val,  # Use global argument
                "video_params": scene_params,
            }
        )

    # 2. Check for Zones File
    zones_file = find_zones_file(src_file)
    final_scenes = base_scenes

    if zones_file:
        console.print(f"[green]Zones file found: {zones_file.name}[/green]")
        console.print("[yellow]Applying zones overrides...[/yellow]")

        # Read zones
        zones = []
        with open(zones_file, "r") as f:
            for line in f:
                if not line.strip() or line.strip().startswith("#"):
                    continue
                parts = line.split(maxsplit=3)  # start, end, enc, params
                if len(parts) < 4:
                    continue
                try:
                    z_start = int(parts[0])
                    z_end_raw = int(parts[1])

                    # Handle -1 as final frame
                    if z_end_raw == -1:
                        z_end = nframe - 1
                    else:
                        z_end = z_end_raw

                    # parts[2] is encoder (ignored mostly), parts[3] is params
                    z_params = parts[3]
                    zones.append((z_start, z_end, z_params))
                except ValueError:
                    console.print(f"[red]Invalid zone line: {line.strip()}[/red]")

        # Apply zones iteratively (Cookie Cutter)
        for z_start, z_end, z_params_str in zones:
            new_list = []

            # z_end in zones.txt is typically inclusive in user intent
            # e.g., "0 270" includes frame 270.
            # Av1an internal scene logic is usually [Start, End) (exclusive end)
            # So the scene logic split point should be z_end + 1

            z_end_exclusive = z_end + 1

            for scene in final_scenes:
                s_start = scene["start_frame"]
                s_end = scene["end_frame"]

                # Check for overlap
                # Overlap if: start1 < end2 AND start2 < end1
                if s_start < z_end_exclusive and z_start < s_end:
                    # Overlap exists. We might need to split into 3 parts:
                    # 1. Pre-zone (Original)
                    # 2. Zone (Modified)
                    # 3. Post-zone (Original)

                    # 1. Pre-zone
                    if s_start < z_start:
                        new_list.append(
                            {
                                "start_frame": s_start,
                                "end_frame": z_start,
                                "photon_noise": scene["photon_noise"],
                                "video_params": scene["video_params"],
                            }
                        )

                    # 2. Zone Intersection
                    # Intersection start: max(s_start, z_start)
                    # Intersection end: min(s_end, z_end_exclusive)
                    int_start = max(s_start, z_start)
                    int_end = min(s_end, z_end_exclusive)

                    # Merge params
                    merged_params, merged_pn = merge_params(
                        scene["video_params"], z_params_str
                    )
                    pn = merged_pn if merged_pn is not None else scene["photon_noise"]

                    new_list.append(
                        {
                            "start_frame": int_start,
                            "end_frame": int_end,
                            "photon_noise": pn,
                            "video_params": merged_params,
                        }
                    )

                    # 3. Post-zone
                    if s_end > z_end_exclusive:
                        new_list.append(
                            {
                                "start_frame": z_end_exclusive,
                                "end_frame": s_end,
                                "photon_noise": scene["photon_noise"],
                                "video_params": scene["video_params"],
                            }
                        )

                else:
                    # No overlap, keep original
                    new_list.append(scene)

            final_scenes = new_list
            # Sort by start frame to be safe
            final_scenes.sort(key=lambda x: x["start_frame"])

    # 3. Construct Final JSON
    scenes_data_output = []
    for s in final_scenes:
        scenes_data_output.append(
            {
                "start_frame": s["start_frame"],
                "end_frame": s["end_frame"],
                "zone_overrides": {
                    "encoder": "svt_av1",
                    "passes": 1,
                    "video_params": s["video_params"],
                    "photon_noise": s["photon_noise"],
                    "photon_noise_height": None,
                    "photon_noise_width": None,
                    "chroma_noise": False,
                    "extra_splits_len": 240,
                    "min_scene_len": 24,
                },
            }
        )

    output_json = {"frames": nframe, "scenes": scenes_data_output}

    with open(scenes_file, "w") as f:
        json.dump(output_json, f, indent=2)

    console.print(
        f"[cyan]Generated Av1an scenes file: {obscure_user_path(str(scenes_file))}[/cyan]"
    )


console.print("[bold]Auto-Boost-Av1an start!\n")

with wakepy.keep.running():
    if no_boosting:
        stage = 4

    match stage:
        case 0:
            if stage_resume < 2:
                fast_pass()
                with open(stage_file, "w") as file:
                    file.write("2")
                print("Stage 1 complete! Now calculating metric scores")
            if stage_resume < 3:
                try:
                    calculate_metric()
                except KeyboardInterrupt:
                    raise SystemExit(1)
                with open(stage_file, "w") as file:
                    file.write("3")
                print("Stage 2 complete!")
            if stage_resume < 4:
                try:
                    ranges, hr, nframe, _, _, _, _ = get_file_info(src_file, "src")
                    calculate_zones_json(ranges, hr, nframe)
                except KeyboardInterrupt:
                    raise SystemExit(1)
                with open(stage_file, "w") as file:
                    file.write("4")
                print("Stage 3 complete!")
            if stage_resume < 5:
                final_pass()
                try:
                    shutil.move(tmp_final_output_file, final_output_file)
                except:
                    pass  # Can crash if same file
                with open(stage_file, "w") as file:
                    file.write("5")
                print("Stage 4 complete!")
        case 1:
            fast_pass()
            with open(stage_file, "w") as file:
                file.write("2")
            print("Stage 1 complete! Now calculating metric scores")
        case 2:
            try:
                calculate_metric()
            except KeyboardInterrupt:
                raise SystemExit(1)
            with open(stage_file, "w") as file:
                file.write("3")
            print("Stage 2 complete!")
        case 3:
            try:
                ranges, hr, nframe, _, _, _, _ = get_file_info(src_file, "src")
                calculate_zones_json(ranges, hr, nframe)
            except KeyboardInterrupt:
                raise SystemExit(1)
            with open(stage_file, "w") as file:
                file.write("4")
            print("Stage 3 complete!")
        case 4:
            final_pass()
            try:
                shutil.move(tmp_final_output_file, final_output_file)
            except:
                pass
            with open(stage_file, "w") as file:
                file.write("5")
            print("Stage 4 complete!")
        case _:
            console.print("[red]Stage argument invalid, exiting.")
            raise SystemExit(1)

console.print("\n[bold]Auto-boost complete!")
